<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>Elf Loader</title>
  <meta name="author" content="Martin Ribelotta" />
  
  
  
  
  <meta name="keywords" content="embedded, electronics, iot, Cortex-m, Microcontroller, ELF, ARM">
  
  
  <meta name="description" content="ourEmbeddeds main site">

  <meta name="generator" content="Hugo 0.74.3" />

  
  <link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>

  
  <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.11.2/css/all.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
    <link href="/css/style.blue.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">

  
  <link rel="alternate" href="https://ourembeddeds.github.io/index.xml" type="application/rss+xml" title="Our Embeddeds">

  
  
  
  
  
  
  
  <meta property="og:locale" content="en_us">
  <meta property="og:site_name" content="Our Embeddeds">
  <meta property="og:title" content="Elf Loader">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://ourembeddeds.github.io/blog/2020/08/16/elf-loader/" />
  <meta property="og:description" content="ourEmbeddeds main site">
  <meta property="og:image" content="https://ourembeddeds.github.io/img/Tomtebobarnen.jpg">
  <meta property="og:image:type" content="image/jpg">
  
  
  
    <meta property="og:image:width" content="371">
    <meta property="og:image:height" content="271">
  
  
  <meta property="og:updated_time" content="2020-08-16T15:08:33-0300">
  
    
    
    <meta property="article:section" content="Embedded">
    
    
    <meta property="article:published_time" content="2020-08-16T15:08:33-0300">
    <meta property="article:modified_time" content="2020-08-16T15:08:33-0300">
  

  
  <meta name="twitter:card" content="summary_large_image">
  
  <meta name="twitter:title" content="Elf Loader">
  
  <meta name="twitter:image" content="https://ourembeddeds.github.io/img/Tomtebobarnen.jpg">
  
  <meta name="twitter:description" content="ourEmbeddeds main site">
  

</head>


  <body>

    <div id="all">

        <header class="navbar-affixed-top" data-spy="affix" data-offset-top="62">
    <div class="navbar navbar-default yamm" role="navigation" id="navbar">    
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/ourembeddeds-banner.png" alt="Elf Loader logo" class="hidden-xs hidden-sm">
                    <img src="/img/logo-small.png" alt="Elf Loader logo" class="visible-xs visible-sm">
                    <span class="sr-only">Elf Loader - go to homepage</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only">Toggle Navigation</span>
                        <i class="fas fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  
                  
                  <li class="dropdown">
                    
                    <a href="/">Home</a>
                    
                  </li>
                  
                  
                  <li class="dropdown active">
                    
                    <a href="/blog/">Blog</a>
                    
                  </li>
                  
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">Contact</a>
                    
                  </li>
                  
                </ul>
            </div>
            

            <div class="collapse clearfix" id="search">    
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search">
                        <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main"><i class="fas fa-search"></i></button>
                </span>
                    </div>
                </form>
            </div>
            
        </div>
    </div>
</header>




        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>Elf Loader</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">

                        
                          <p class="text-muted text-uppercase mb-small text-right">
                            By <a href="#">Martin Ribelotta</a>
                             | 
                            August 16, 2020
                          </p>
                        

                        <div id="post-content">
                          <p>Perfect, you&rsquo;ve created your embedded system, provided it with an
external storage system, created a serial terminal to test things
out, and then started your journey through routine&hellip; testing as
if you were sitting on an old 70&rsquo;s ticker while you listen to
&ldquo;Sheer Heart Attack&rdquo; by Queen (a plus for the sound without a
synth)</p>
<div class="toc">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#elf-load-dynamic-load-and-execute-for-your-mcu">ELF Load: Dynamic load and execute for your mcu.</a>
      <ul>
        <li><a href="#loading-binaries-the-simplest-way">Loading binaries, the simplest way</a></li>
        <li><a href="#fixing-the-world-one-word-at-time">Fixing the world one word at time</a></li>
        <li><a href="#put-ya-guns-on">Put ya guns on!</a></li>
        <li><a href="#system-interface">System interface</a></li>
      </ul>
    </li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
</div>
<h2 id="elf-load-dynamic-load-and-execute-for-your-mcu">ELF Load: Dynamic load and execute for your mcu.</h2>
<p>But wait! This is not totally the old-fashionist experience&hellip;
My binaries must be embedded in the firmware in order to work!
You also shouldn&rsquo;t expect to be able to listen to your old
5&rsquo;&rsquo; 1/4 drive (or better, your dataset) but the fresh experience
of binary loaded is lost for ever and never&hellip; or not?</p>
<h3 id="loading-binaries-the-simplest-way">Loading binaries, the simplest way</h3>
<p>In an old PC, when you type a command, the operating system
searchs a file with the command name and extension COM (or EXE in
newer versions) and tries to load it&hellip; At this moment, several
things happen:</p>
<ol>
<li>The system calculates memory usage of the executable and
reserves this amount of memory in the system</li>
<li>The OS reads the file and copies the pertinent areas in the
reserved memory.</li>
<li>Depending on architecture, some adjustments to loaded data may
be needed. In the case of 8086 and <code>*.com</code> files, the architecture
of the memory management unit enables load without any adjustments in
this phase.</li>
<li>An execution environment is created (reserving memory if
required) and configures some registers of the processor to point
to this environment before the next phase</li>
<li>Finally, the OS jumps to the entry point of binary and
delegates the execution to the recently loaded code</li>
</ol>
<p>As mentioned in the point 3, normally in a PC processor the
architecture enables execution with minimun or unexisting
binary modifications (segmentation in 8086 and MMU in modern x86
systems).</p>
<p>You can see next, the 8086 memory layout at COM executable load:</p>
<p><img src="/img/articles/elf-loader/8086-executable-load.png" alt="8086-executable-load"></p>
<p>In this example, the binary is limited to 64K of memory
and the processor reserves one of the segments for the program usage
(in the execution, the program can load more code or request
more memory to OS, but the binary is limited to one 64K segment).
In modern systems with a memory management unit (MMU), you can map any virtual direction
to any real direction (well, not exactly&hellip; in 4K blocks of granularity, but you do understand, right?)
and can select the memory layout of your executable freely.</p>
<p><img src="/img/articles/elf-loader/VM-executable-load.png" alt="VM-executable-load"></p>
<p>Usually, the process to load executable in MMU systems is more complex, involves copy of a portion of the file
dynamically at request using a virtual memory trick called page-fault. In short, you only need to configure the
memory of your process with required pages and mark as no-present this pages; at the moment is necessary to
access these pages, the hardware triggers an interrupt thath is caught by the OS who proceeds to load these pages
for you.. cool don&rsquo;t you think?.</p>
<p>But when you try to replicate this behavior in your embedded system&hellip; the magic is gone and you will quickly see
the problem: You need to use fixed address for your binary load:</p>
<p><img src="/img/articles/elf-loader/mcu-executable-load.png" alt="mcu-executable-load"></p>
<p>This schema works more or less properly for a single executable,
but if you need nested executable load or multithread load, this
approach is quickly wasted.</p>
<p>In many architectures (highlighting ARM, MIPS and RISC-V) the jumps normally refer to the current program counter
(PC) to jump. In this architectures, the code is easy loadable in any position of memory (respecting some rules
of aligns) but the data is more complex because it needs one or two indirections to refer a proper memory area
independently of the load position.</p>
<h3 id="fixing-the-world-one-word-at-time">Fixing the world one word at time</h3>
<p>If your processor lacks MMU, to load programs at arbitrary addresses, you can look for several approaches:</p>
<ul>
<li>
<p>Make the code suitable to detect the current address and adjust their references in accordance to it: This is
called &ldquo;position independent code&rdquo; or PIC (similar approach with very subtle differences is called &ldquo;position
independent executable&rdquo; or PIE) and implies one or two levels of indirection in any code. But don&rsquo;t celebrate
yet, the PIC code has various challenges to solve:</p>
<ul>
<li>Jump of code independent of position: This normally is made
using special processor features like PC relative jumps.
This is easy when the compiler knows the relative position
of code in compile time, but becomes difficult when the
address of the code is dinamically calculated, like in jump
tables.</li>
<li>Access data in arbitrary loadable position: Normally, the PIC code uses indirect access through a
relocation table called global offset table (GOT) modified by the loader before code startup.</li>
<li>Mix of previous points: Normally, when your code jumps to
a calculated position, you need a GOT entry reserved for
this calculus and need to adjust this entry like other
data access. Due to optimization, the compiler may
prefer other approach, using an stub of code
adjustable at startup for perform this dynamic jump. This
technique is called procedure linkage table and consists in a
little stub of code that performs a call to undefined pointer
(normally an error function) and the loader adjusts this code
in load time to point to the correct code block. This
approach enables you to share code in libraries, although it requires a little more of work.</li>
</ul>
</li>
<li>
<p>Leave any memory reference as undefined and mark in a table the needed to modify this portion of code in
order for the program to work.</p>
</li>
</ul>
<p>The first approach needs less work in the loader area but the
performance at runtime is worse than the fixed memory address code.
In contrast, the second approach needs more loader work but the
performance of the code is nearly the same as the fixed
address code&hellip;</p>
<p>In the end, the PIC code is the only suitable way to share code across multiple libraries for single binaries.
For example, with the PIC code you can have a one library for string formatting (aka printf) and share the
code with many programs. Additionally, the PIC code can reside in flash without any modifications, only a
PLT and GOT is required in RAM, and change from program to program (this require OS help on context switch).</p>
<h6 id="global-offset-table-schema">Global offset table schema</h6>
<p><img src="/img/articles/elf-loader/got-operation.png" alt="got-operation"></p>
<h6 id="relocation-schema">Relocation schema</h6>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-as" data-lang="as"><span style="color:#999;font-style:italic">// extern int f1(int, int, char);
</span><span style="color:#999;font-style:italic">// void func1() {
</span><span style="color:#999;font-style:italic">//   f1(0, 0xAA55AA55, 32);
</span><span style="color:#999;font-style:italic"></span>  movs    r2, <span style="color:#a61717;background-color:#e3d2d2">#</span><span style="color:#3677a9">32</span>
  movs    r0, <span style="color:#a61717;background-color:#e3d2d2">#</span><span style="color:#3677a9">0</span>
  ldr     r1, [pc, <span style="color:#a61717;background-color:#e3d2d2">#</span><span style="color:#3677a9">4</span>]    <span style="color:#999;font-style:italic">// &lt;func1+0xc&gt;
</span><span style="color:#999;font-style:italic"></span>  ldr     r3, [pc, <span style="color:#a61717;background-color:#e3d2d2">#</span><span style="color:#3677a9">8</span>]    <span style="color:#999;font-style:italic">// &lt;func1+0x10&gt;
</span><span style="color:#999;font-style:italic"></span>  bx      r3
  nop <span style="color:#999;font-style:italic">// Align instruction
</span><span style="color:#999;font-style:italic"></span>  .word   <span style="color:#3677a9">0xaa55aa55</span>
  .word   <span style="color:#3677a9">0x00000000</span> <span style="color:#999;font-style:italic">// &lt;f1&gt; replace with addr of symbol
</span></code></pre></div><h3 id="put-ya-guns-on">Put ya guns on!</h3>
<p>Our preferred approach in embedded systems is to load the code and
relocate individual references instead of GOT usage due to the
performance degradation of adding two indirections (one for GOT
pointer and one for GOT entry) in every memory access.</p>
<p>In MMU systems, the ELF load process is really straightforward:</p>
<ul>
<li>Map the file from disk to memory (with help from MMU and OS swap
service) and resolve memory map to satisfy the ELF layout.</li>
<li>Scan a relocation table and resolve undefined symbols (normally
from dynamic libraries in the system).</li>
<li>Make a process environment and adjust the process register to point to it (normally an in-memory structure
representing the process state).</li>
<li>Let the OS load the new processor state with the correct
environment. Normally, this is limited to putting the process
state in a ready queue in the OS structures and letting the
scheduler do the switch process when available.</li>
</ul>
<p>Without MMU, the process require some precautions:</p>
<ol>
<li>You cannot load the entire ELF from secondary storage because
this action consumes more memory than expected (the ELF
may contains debugging sections, some unneeded information
like symbol tables and other non required data at runtime).</li>
<li>The memory is non-virtualized, all process share the same
memory space and can potentially access (in a harmful way)
the memory from other process&hellip; You need to take precautions,
some MCU have a protection memory system (like MPU on ARM
or PMP on RISC-V) to mitigate this issue.</li>
<li>You need to reserve only loadable sections like <code>.text</code>,
<code>.data</code>, <code>.rodata</code>, <code>.bss</code>, and <code>.stack</code>, other sections
are only used at the load time like relocation symbols and
elf header.</li>
<li>You need to travel trough all symbols and relocate every
entry in the binary&hellip; this may take some time but the execution
time has little impact compared with the PIC code.</li>
</ol>
<p>You can see our implementation of the load-relocate schema in
<a href="https://github.com/martinribelotta/elfloader">this link</a>.</p>
<p>Due to the simple nature of the loader, it cannot handle all type of
relocations and sections. Ideally, you can extend the code to
cover your necessities, but the actual implementation works fine
with some precautions at the moment of guest binary compilation:</p>
<ul>
<li>You cannot use &ldquo;COMMON&rdquo; sections, all of non initialized data must
be in BSS. The gcc flag to force this is <code>-fno-common</code>.</li>
<li>You need to link the final ELF as a relocatable executable.
This prevents the linker from resolving undefined symbols,
instead it embeds the information needed to resolve the symbols in the
binary. The gcc or ld flag to force this linking behavior is
<code>-r</code>.</li>
<li>You need to force the compiler to produce only &ldquo;word
relocation&rdquo; types. This is the simplest relocation form and
is easier to handle in load time. In ARM architecture, this
forces all relocations to be of type <code>R_ARM_ABS32</code>. To enable
this, gcc for ARM provides the flag: <code>-mlong-call</code>. In old
compilers this is not strictly true and the flag will not produce correct results,
many relocations will be of type <code>R_ARM_THB_CALL</code> or
<code>R_ARM_THB_JMP</code>. Don&rsquo;t panic, the actual loader can handle this
type of relocations, but the load phase will be sensibly slower
due to major processing work.</li>
<li>By default, all compilers provide a startup library that is
executed before main, and initializes some data and code for you,
but this is undesirable in this situation. You need to disable
the inclusion of these codes and provide a self written version
to <code>_start</code> or other function of your election. This behavior
can be enabled in gcc using the <code>-nostartfiles</code> flag.</li>
</ul>
<p>Additionally, you can provide a linker script with your preferred
memory layout, but the suggested minimum linker script layout looks
like this:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ENTRY(_start)
SECTIONS
{
	.text <span style="color:#3677a9">0x00000000</span> :
	{
		*(.text* .text.*)
	}
	.rodata :
	{
		*(.rodata* .rodata.*)
	}
	.data :
	{
		*(.data* .data.*)
	}
	.bss :
	{
		*(.bss .bss.* .sbss .sbss.* COMMON)
	}
</code></pre></div><p>This places all sections in contiguous memory. If your architecture
requires some align, you need to add &ldquo;<code>. = ALIGN(n);</code>&rdquo; statements
between sections.</p>
<p>At this point, the loader API is really simple:</p>
<h4 id="initialize-it">Initialize it.</h4>
<p>You need to define an environment variable for the new binary
with:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6ab825;font-weight:bold">typedef</span> <span style="color:#6ab825;font-weight:bold">struct</span> {
   <span style="color:#6ab825;font-weight:bold">const</span> ELFSymbol_t *exported;
   size_t exported_size;
} ELFEnv_t;
...
<span style="color:#6ab825;font-weight:bold">const</span> ELFEnv_t elfEnv = {
   symbolTable,
   <span style="color:#6ab825;font-weight:bold">sizeof</span>(symbolTable) / <span style="color:#6ab825;font-weight:bold">sizeof</span>(ELFSymbol_t)
};
</code></pre></div><p>This contain a reference to an array of resolvable symbols
and the number of the elements inside the array. The entries of
this array contain the name and the pointer to be resolved:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6ab825;font-weight:bold">typedef</span> <span style="color:#6ab825;font-weight:bold">struct</span> {
  <span style="color:#6ab825;font-weight:bold">const</span> <span style="color:#6ab825;font-weight:bold">char</span> *name; <span style="color:#999;font-style:italic">/*!&lt; Name of symbol */</span>
  <span style="color:#6ab825;font-weight:bold">void</span> *ptr; <span style="color:#999;font-style:italic">/*!&lt; Pointer of symbol in memory */</span>
} ELFSymbol_t;
...
<span style="color:#6ab825;font-weight:bold">const</span> ELFSymbol_t symbolTable[] = {
   { <span style="color:#ed9d13">&#34;printf&#34;</span>, (<span style="color:#6ab825;font-weight:bold">void</span>*) printf },
   { <span style="color:#ed9d13">&#34;scanf&#34;</span>, (<span style="color:#6ab825;font-weight:bold">void</span>*) scanf },
   { <span style="color:#ed9d13">&#34;strstr&#34;</span>, (<span style="color:#6ab825;font-weight:bold">void</span>*) strstr },
   { <span style="color:#ed9d13">&#34;fctrl&#34;</span>, (<span style="color:#6ab825;font-weight:bold">void</span>*) fctrl },
};
</code></pre></div><p>Additionally, you need to create an object of type
<code>loader_env_t</code> and set the symbol table inside this struct.</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ELFExec_t *exec;
loader_env_t loader_env;
loader_env.env = env;
</code></pre></div><p>In the next phase, you need to call <code>load_elf</code> with the PATH of
the binary, the environment and a reference to the pointer of
<code>ELFExec_t</code>:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">load_elf(<span style="color:#ed9d13">&#34;/flash/bin/test1.elf&#34;</span>, loader_env, &amp;exec);
</code></pre></div><p>If the operation ends successfully, the return status is <code>0</code>. In
case of an error, it will return negative number indicating the specific error.</p>
<p>In this point, you have the binary loaded and allocated in the
memory, and you can jump into start entry point or request the
address of specific symbols:</p>
<p>In the first case, you need to call the function like this:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6ab825;font-weight:bold">int</span> ret = jumpTo(exec);
<span style="color:#6ab825;font-weight:bold">if</span> (ret...
</code></pre></div><p>If the program ends successfully, the function returns 0, otherwise
it will return a negative number depending to the error.</p>
<p>If you need to request an specific function pointer you can use</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6ab825;font-weight:bold">void</span> *symbolPtr = get_func(<span style="color:#ed9d13">&#34;myFunction&#34;</span>, exec);
</code></pre></div><p>This returns a pointer to the function start or <code>NULL</code> if the object
is not found.</p>
<p>If you need an arbitrary pointer to other symbol (variable,
constant or whatever) you can use:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#6ab825;font-weight:bold">void</span> *symbolPtr = get_obj(<span style="color:#ed9d13">&#34;myVar&#34;</span>, exec);
</code></pre></div><p>After all, you can free all allocated memory for the binary and
the metadata of the ELF file with:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">unload_elf(exec);
</code></pre></div><h3 id="system-interface">System interface</h3>
<p>In order to be flexible in the implementation, the library leaves
undefined some API of low level access for port to any system.</p>
<p>The low level layer need the following macros defined:</p>
<ul>
<li><code>LOADER_USER_DATA</code>: Structure or datatype to contain the
platform dependent data for file access. For example, this needs
at least, a file object (integer file descriptor, FILE* struct,
or whatever) and an environment pointer to <code>ELFEnv_t</code>.</li>
<li><code>LOADER_OPEN_FOR_RD(userdata, path)</code>: open file in path and
modify userdata in order to save the file descriptor, or file
pointer.</li>
<li><code>LOADER_FD_VALID(userdata)</code>: Check if the opened file data is
a valid file and can be read from.</li>
<li><code>LOADER_READ(userdata, buffer, size)</code>: Read <code>size</code> bytes from
file descriptor in <code>userdata</code> and put it in <code>buffer</code> array.</li>
<li><code>LOADER_WRITE(userdata, buffer, size)</code>: Write <code>size</code> bytes to
file descriptor in <code>userdata</code> from <code>buffer</code> pointer.
This macro is not used internally, it is only defined
in symmetry with the macro above.</li>
<li><code>LOADER_CLOSE(userdata)</code>: Close the file descriptor in
<code>userdata</code>.</li>
<li><code>LOADER_SEEK_FROM_START(userdata, off)</code>: Move read pointer
<code>off</code> bytes from the start of file pointed by descriptor in
<code>userdata</code>.</li>
<li><code>LOADER_TELL(userdata)</code>: Return current position of file
descriptor in <code>userdata</code>.</li>
<li><code>LOADER_ALIGN_ALLOC(size, align, perm)</code>: Return <code>size</code> bytes
aligned as <code>align</code> bytes with <code>perm</code> permission access. If you
do not provides differentiate access of memory region, the returned
region can be write, read and execute. By default, the macro
call a function <code>void *do_alloc(size_t size, size_t align,  ELFSecPerm_t perm);</code>.</li>
<li><code>LOADER_FREE(ptr)</code>: Deallocate memory from pointer <code>ptr</code></li>
<li><code>LOADER_STREQ(s1, s2)</code>: Compare two strings s1, and s2. The
result of equal strings must be <strong><code>!= 0</code></strong> and when the strings
differ, the result of this macro must be <strong><code>0</code></strong>. The simplest
implementation is: <code>(strcmp((s1), (s2)) == 0)</code></li>
<li><code>LOADER_JUMP_TO(entry)</code>: Perform a jump to application entry
point. <code>entry</code> is the address of the first instruction of the
code. You can simply cast the value to a function pointer with
selected fingerprint or do a more complex operation like
environment creation, start a new RTOS thread or whatever
is required for your architecture.</li>
<li><code>DBG(...)</code>: Print (in printf like format) debug messages. Can
be empty if you do not need debug messages.</li>
<li><code>ERR(...)</code>: Print (in printf like format) error messages. Can
be empty if you do not need error messages.</li>
<li><code>MSG(msg)</code>: Print (in printf like format) information
messages. Can be empty if you do not need information messages.</li>
<li><code>#define LOADER_GETUNDEFSYMADDR(userdata, name)</code>: Resolve
symbol name <code>name</code> and return its address. The most
simple way to do this is to perform a search in specific structure
under <code>userdata</code> with a symbol table. If the process fail, the
data returned must be <code>0xffffffff</code> AKA <code>((uint32_t) -1)</code></li>
</ul>
<p>The golden implementation uses ARM semihosting IO for file access, but you can port this to any API like fatfs or similar.</p>
<h2 id="references">References</h2>
<p><a href="https://github.com/martinribelotta/elfloader">elf-loader</a></p>
<p><a href="https://github.com/niicoooo/esp32-elfloader">elf-loader for esp32 implementation</a></p>
<p><a href="https://en.wikipedia.org/wiki/COM_file">MSDOS COM Executable</a></p>
<p><a href="https://en.wikipedia.org/wiki/Relocation_(computing)">Relocation technics</a></p>
<p><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF file format</a></p>
<p><a href="https://lwn.net/Articles/631631/">Executable an linkable file load on linux</a></p>
<p><a href="https://wiki.osdev.org/ELF_Tutorial">More ELF information with relocation format</a></p>
<p><a href="https://static.docs.arm.com/ihi0044/e/IHI0044E_aaelf.pdf">ELF Relocation types from ARM</a> The main goal is section 4.6 explaining all relocation formats</p>
                        </div>
                        
                        

                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        

<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">Search</h3>
    </div>

    <div class="panel-body">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" role="search">
            <div class="input-group">
                <input type="search" name="q" class="form-control" placeholder="Search">
                <input type="hidden" name="sitesearch" value="https://ourembeddeds.github.io/">
                <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main"><i class="fas fa-search"></i></button>
                </span>
            </div>
        </form>
    </div>
</div>







<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">Categories</h3>
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            
            <li>
                <a href="/categories/arm">arm (2)</a>
            </li>
            
            <li>
                <a href="/categories/embedded">embedded (2)</a>
            </li>
            
            <li>
                <a href="/categories/institutional">institutional (1)</a>
            </li>
            
            <li>
                <a href="/categories/microcontrollers">microcontrollers (2)</a>
            </li>
            
        </ul>
    </div>

</div>













                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4>About us</h4>

            <p>Embedded developers professional group.</p>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>Recent posts</h4>

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://ourembeddeds.github.io/blog/2020/09/05/armv7m-startup/">
                          
                            <img src="/img/articles/armv7m-boot/baron-bootstrapping.jpg" class="img-responsive" alt="Armv7m Startup">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://ourembeddeds.github.io/blog/2020/09/05/armv7m-startup/">Armv7m Startup</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://ourembeddeds.github.io/blog/2020/08/16/elf-loader/">
                          
                            <img src="/img/Tomtebobarnen.jpg" class="img-responsive" alt="Elf Loader">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://ourembeddeds.github.io/blog/2020/08/16/elf-loader/">Elf Loader</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://ourembeddeds.github.io/blog/2020/08/06/first-post/">
                          
                            <img src="/img/ourembeddeds.png" class="img-responsive" alt="Welcome to our site">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://ourembeddeds.github.io/blog/2020/08/06/first-post/">Welcome to our site</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6">

          <h4>Contact</h4>

            <p class="text-uppercase"><strong>Bariloche</strong>
        <br>Vte O'Connor 647
        <br>Floor 5, Box 2
        <br>Rio Negro
        <br>
        <strong>Argentina</strong>
      </p>
      

            <a href="/contact" class="btn btn-small btn-template-main">Go to contact page</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright (c) 2020, OurEmbeddeds; all rights reserved.</p>
            
            <p class="pull-right">
              Template by <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
              

              Ported to Hugo by <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-177396015-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

<script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>

<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>



  </body>
</html>
